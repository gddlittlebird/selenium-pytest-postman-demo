{"name": "test_login_performance[user_data2]", "status": "broken", "statusDetails": {"message": "RuntimeError: 浏览器启动失败: Could not reach host. Are you offline?", "trace": "urllib3.exceptions.SSLError: [SSL: UNEXPECTED_EOF_WHILE_READING] EOF occurred in violation of protocol (_ssl.c:1000)\n\nThe above exception was the direct cause of the following exception:\n\nself = <requests.adapters.HTTPAdapter object at 0x05DE73C0>, request = <PreparedRequest [GET]>, stream = True, timeout = Timeout(connect=None, read=None, total=None), verify = True, cert = None\nproxies = OrderedDict({'http': 'http://127.0.0.1:7890', 'https': 'http://127.0.0.1:7890', 'ftp': 'http://127.0.0.1:7890'})\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection_with_tls_context(\n                request, verify, proxies=proxies, cert=cert\n            )\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n>           resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n\nD:\\Python312-32\\Lib\\site-packages\\requests\\adapters.py:667: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nD:\\Python312-32\\Lib\\site-packages\\urllib3\\connectionpool.py:841: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = 'GET', url = '/chrome-for-testing/latest-patch-versions-per-build.json', response = None\nerror = SSLError(SSLEOFError(8, '[SSL: UNEXPECTED_EOF_WHILE_READING] EOF occurred in violation of protocol (_ssl.c:1000)')), _pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x05DE74F8>\n_stacktrace = <traceback object at 0x05E63DA8>\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\nE           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='googlechromelabs.github.io', port=443): Max retries exceeded with url: /chrome-for-testing/latest-patch-versions-per-build.json (Caused by SSLError(SSLEOFError(8, '[SSL: UNEXPECTED_EOF_WHILE_READING] EOF occurred in violation of protocol (_ssl.c:1000)')))\n\nD:\\Python312-32\\Lib\\site-packages\\urllib3\\util\\retry.py:519: MaxRetryError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <webdriver_manager.core.http.WDMHttpClient object at 0x05DE71F8>, url = 'https://googlechromelabs.github.io/chrome-for-testing/latest-patch-versions-per-build.json', kwargs = {}\n\n    def get(self, url, **kwargs) -> Response:\n        try:\n>           resp = requests.get(\n                url=url, verify=self._ssl_verify, stream=True, **kwargs)\n\nD:\\Python312-32\\Lib\\site-packages\\webdriver_manager\\core\\http.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nD:\\Python312-32\\Lib\\site-packages\\requests\\api.py:73: in get\n    return request(\"get\", url, params=params, **kwargs)\nD:\\Python312-32\\Lib\\site-packages\\requests\\api.py:59: in request\n    return session.request(method=method, url=url, **kwargs)\nD:\\Python312-32\\Lib\\site-packages\\requests\\sessions.py:589: in request\n    resp = self.send(prep, **send_kwargs)\nD:\\Python312-32\\Lib\\site-packages\\requests\\sessions.py:703: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x05DE73C0>, request = <PreparedRequest [GET]>, stream = True, timeout = Timeout(connect=None, read=None, total=None), verify = True, cert = None\nproxies = OrderedDict({'http': 'http://127.0.0.1:7890', 'https': 'http://127.0.0.1:7890', 'ftp': 'http://127.0.0.1:7890'})\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection_with_tls_context(\n                request, verify, proxies=proxies, cert=cert\n            )\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            resp = conn.urlopen(\n                method=request.method,\n                url=url,\n                body=request.body,\n                headers=request.headers,\n                redirect=False,\n                assert_same_host=False,\n                preload_content=False,\n                decode_content=False,\n                retries=self.max_retries,\n                timeout=timeout,\n                chunked=chunked,\n            )\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n                raise RetryError(e, request=request)\n    \n            if isinstance(e.reason, _ProxyError):\n                raise ProxyError(e, request=request)\n    \n            if isinstance(e.reason, _SSLError):\n                # This branch is for urllib3 v1.22 and later.\n>               raise SSLError(e, request=request)\nE               requests.exceptions.SSLError: HTTPSConnectionPool(host='googlechromelabs.github.io', port=443): Max retries exceeded with url: /chrome-for-testing/latest-patch-versions-per-build.json (Caused by SSLError(SSLEOFError(8, '[SSL: UNEXPECTED_EOF_WHILE_READING] EOF occurred in violation of protocol (_ssl.c:1000)')))\n\nD:\\Python312-32\\Lib\\site-packages\\requests\\adapters.py:698: SSLError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <core.browser_manager.BrowserManager object at 0x05DE7150>, browser_type = 'chrome'\n\n    def start_browser(self,browser_type=\"chrome\"):\n        \"\"\"\n        启动浏览器\n        默认启动Chrome。\n        \"\"\"\n        try:\n            print(f\"正在启动浏览器\")\n            self.logger.info(\"正在启动Chrom浏览器(自我驱动管理)...\")\n            #print(f\"无头模式状态: {self.headless_mode}\")\n    \n            #启动Chrome浏览器服务\n>           service = ChromeService(executable_path=ChromeDriverManager().install())\n\n..\\core\\browser_manager.py:90: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nD:\\Python312-32\\Lib\\site-packages\\webdriver_manager\\chrome.py:40: in install\n    driver_path = self._get_driver_binary_path(self.driver)\nD:\\Python312-32\\Lib\\site-packages\\webdriver_manager\\core\\manager.py:35: in _get_driver_binary_path\n    binary_path = self._cache_manager.find_driver(driver)\nD:\\Python312-32\\Lib\\site-packages\\webdriver_manager\\core\\driver_cache.py:107: in find_driver\n    driver_version = self.get_cache_key_driver_version(driver)\nD:\\Python312-32\\Lib\\site-packages\\webdriver_manager\\core\\driver_cache.py:154: in get_cache_key_driver_version\n    return driver.get_driver_version_to_download()\nD:\\Python312-32\\Lib\\site-packages\\webdriver_manager\\core\\driver.py:48: in get_driver_version_to_download\n    return self.get_latest_release_version()\nD:\\Python312-32\\Lib\\site-packages\\webdriver_manager\\drivers\\chrome.py:59: in get_latest_release_version\n    response = self._http_client.get(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <webdriver_manager.core.http.WDMHttpClient object at 0x05DE71F8>, url = 'https://googlechromelabs.github.io/chrome-for-testing/latest-patch-versions-per-build.json', kwargs = {}\n\n    def get(self, url, **kwargs) -> Response:\n        try:\n            resp = requests.get(\n                url=url, verify=self._ssl_verify, stream=True, **kwargs)\n        except exceptions.ConnectionError:\n>           raise exceptions.ConnectionError(f\"Could not reach host. Are you offline?\")\nE           requests.exceptions.ConnectionError: Could not reach host. Are you offline?\n\nD:\\Python312-32\\Lib\\site-packages\\webdriver_manager\\core\\http.py:35: ConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nfixturedef = <FixtureDef argname='browser' scope='function' baseid='tests'>, request = <SubRequest 'browser' for <Function test_login_performance[user_data2]>>\n\n    @pytest.hookimpl(wrapper=True)\n    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:\n        asyncio_mode = _get_asyncio_mode(request.config)\n        if not _is_asyncio_fixture_function(fixturedef.func):\n            if asyncio_mode == Mode.STRICT:\n                # Ignore async fixtures without explicit asyncio mark in strict mode\n                # This applies to pytest_trio fixtures, for example\n>               return (yield)\n\nD:\\Python312-32\\Lib\\site-packages\\pytest_asyncio\\plugin.py:681: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nconftest.py:7: in browser\n    driver = browser.start_browser()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <core.browser_manager.BrowserManager object at 0x05DE7150>, browser_type = 'chrome'\n\n    def start_browser(self,browser_type=\"chrome\"):\n        \"\"\"\n        启动浏览器\n        默认启动Chrome。\n        \"\"\"\n        try:\n            print(f\"正在启动浏览器\")\n            self.logger.info(\"正在启动Chrom浏览器(自我驱动管理)...\")\n            #print(f\"无头模式状态: {self.headless_mode}\")\n    \n            #启动Chrome浏览器服务\n            service = ChromeService(executable_path=ChromeDriverManager().install())\n            #创建 webDriver 实例\n            driver = webdriver.Chrome(service=service, options=self.options)\n    \n            #注入 JS 脚本，将 navigator.webdriver 设置为 undefined\n            driver.execute_cdp_cmd(\"Page.addScriptToEvaluateOnNewDocument\", {\n                \"source\": \"\"\"\n                           Object.defineProperty(navigator, 'webdriver', {get: () => undefined})\n                       \"\"\"\n            })\n    \n            print(\"Chrome启动成功！\")\n    \n            #把局部driver 赋值给self.driver\n            self.driver = driver\n            #智能等待，元素是否出现在页面上并且是可见的，最多等待10S。\n            self.wait = WebDriverWait(self.driver, 10)\n    \n            return self.driver\n    \n        except Exception as e:\n            import traceback\n            traceback.print_exc()\n>           raise RuntimeError(f\"浏览器启动失败: {str(e)}\")\nE           RuntimeError: 浏览器启动失败: Could not reach host. Are you offline?\n\n..\\core\\browser_manager.py:113: RuntimeError"}, "description": "\n    测试多个用户登录的响应时间，确保在可接受的范围内\n    每个用户从users.csv文件中读取，并记录其登录耗时。\n    若登录失败，将截图并写入日志。\n    ", "parameters": [{"name": "user_data", "value": "{'username': 'alltester_勿动', 'password': 'abc123456'}"}], "start": 1754633734722, "stop": 1754633734722, "uuid": "200c6972-d524-4344-86e5-672631d4084c", "historyId": "110335e58656d9c8e02e7783c2637bf0", "testCaseId": "41a98be2e5ba8dfd29fb449496735cd9", "fullName": "tests.test_login_performance#test_login_performance", "labels": [{"name": "feature", "value": "登录性能测试"}, {"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "test_login_performance"}, {"name": "host", "value": "DESKTOP-I66F8NN"}, {"name": "thread", "value": "21680-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.test_login_performance"}]}